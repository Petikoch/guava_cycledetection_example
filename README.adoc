= Comparing Guava's CycleDetectingLockFactory with jtwfg regarding cycle (deadlock) detection
Peti Koch
:imagesdir: ./images

Peti Koch +
30 April  2015

== Guava CycleDetectingLockFactory, jtwfg ... wtf?

https://github.com/google/guava[Guava] is a feature-rich java library with incredible tools in it,
a must have for almost any Java project out there. It includes since version 13.0 the CycleDetectingLockFactory class, altough still @Beta, even in 18.0.

https://github.com/Petikoch/jtwfg[jtwfg] is a small java library focusing just on finding deadlocks (cycles)
in directed graphs. jtwfg is pretty new (started in late 2014).

== Motivation

My name is Peti Koch. I'm the author of jtwfg and didn't know about Guava's CycleDetectingLockFactory when I started jtwfg.
I wondered if Guava's CycleDetectingLockFactory could solve the same problem as jtwfg and therefore jtwfg is obsolete and could be deleted.

== Analysis

I checked out the features of Guava's CycleDetectingLockFactory using link:src/test/groovy/ch/petikoch/examples/guava/Guava_CycleDetection_Example.groovy[these tests] (based on Groovy/Spock).

=== Analysis regarding cycle detection / deadlock finding

There are two main differences between the guava class and jtwfg.

==== Difference 1: Preventing vs Detecting

Guava's CycleDetectingLockFactory ensures, that there is no cycle in the lock acquisition *order*, to *prevent* *potential* deadlocks.
At the moment, the implementation comes with the price of _false positives_ footnote:[https://github.com/google/guava/issues/2042].

jtwfg *analyzes* a current situation to check, if there *is* a deadlock situation.

What about using jtwfg also for deadlock preventing? This is of course possible: Let's assume we hook into (intercept) the
"dependency building process" at runtime: There is one task trying to add a new dependency to another task. Before allowing this,
we build the current situation (task wait for graph model), check for deadlocks (none expected) and add then the new task/dependency
and check for deadlocks again. If there is no deadlock, we *allow* the new dependency, otherwise we reject it (throwing an exception, ...)
to prevent the deadlock.

What about extending Guava's CycleDetectingLockFactory for *detection*? Well, for deadlock-situations associated with threads and *locks*
there is already Java's built in `java.lang.management.ThreadMXBean` class, which implements this footnote:[https://docs.oracle.com/javase/7/docs/api/java/lang/management/ThreadMXBean.html].

==== Difference 2: Domain Model

Guava's CycleDetectingLockFactory works only in Java's `java.util.concurrent.locks.Lock` domain.
Although it uses internally a generic graph domain model, you would have to transform your domain model
to `java.util.concurrent.locks.Lock` 's, if you would like to use it's cycle detection mechanism.

jtwfg has a generic task wait for graph model.

=== Analysis regarding visualization of graphs

[cols="3*", options="header"]
|===
|Feature
|Guava's CycleDetectingLockFactory
|jtwfg

|Export to other formats like e.g. DOT, GML, ...
|*No*
|*No*

|Create human readable text explaining the cycle
|*Yes*
|*Yes*
|===

=== Analysis regarding preconditions for usage

[cols="3*", options="header"]
|===
|Feature
|Guava's CycleDetectingLockFactory
|jtwfg

|Dependencies on other libs
|none
|none

|Minimum JRE version
|Java *6*
|Java *7*

|Licence
|Apache 2.0
|Apache 2.0
|===


== Summary

This is work in progress. I wonder what the Google people reply on https://github.com/google/guava/issues/2042.

Best regards,

image::Signature.jpg[]